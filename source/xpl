#!/usr/bin/perl

# FIXME Currently every source file must have a <script> element (even if empty)
# The script element is wrapped here, and called at run-time.
# Some source files just need to include other files and shouldn't need a script element.

use strict 'refs';
use warnings;

{
package XPLBuilder;

use URI;
use Cwd;

use LWP::UserAgent;
use HTTP::Request;
our $userAgent = LWP::UserAgent->new;
$userAgent->agent("XPL/0.1 ");

use XML::LibXML;


sub new {
	my $class = shift;
	my $self = {};
	bless($self, $class);
	$self->{requiredDocuments} = {};
	$self->{prefetchedDocuments} = {};
	$self->{params} = {};
	$self->{diskCache} = {};
	$self->{makeDepend} = 0;
	return $self;
}


sub build() {
	my $self = shift;
	my $href = shift;
	my $uri = URI->new($href);
	if ($uri->scheme) {
		$self->{baseURI} = $uri;
	}
	else {
		my $baseURI = URI->new_abs($href, "file://localhost" . getcwd() . "/");
		$self->{baseURI} = $baseURI;
		my $fname = $baseURI->rel( $baseURI );
		$uri = URI->new($fname);
	}
		
	
	while (<main::DATA>) {
		print;
	}
	$self->buildFromUri($uri);
	print <<"";
Meeko.stuff.xplSystem.init();

}

sub expandParams() {
	my $self = shift;
	my ($text) = @_;
	for my $name (keys %{$self->{params}}) {
		my $value = $self->{params}->{$name};
		$text =~ s/\{$name\}/$value/eg;
	}
	return $text;
}

sub prefetchFromUri() {
	my $self = shift;
	my $uri = shift;
	my $fetchUri = $uri;

	if (!$uri->scheme) { die "" . $uri . " is not an absolute uri\n"; }
	elsif ($self->{diskCache}->{$uri}) {
		$fetchURI = URI->new_abs($self->{diskCache}->{$uri}, "file://localhost");
	}
	my $rq = HTTP::Request->new(GET => $fetchURI);
	my $res = $userAgent->request($rq);
	($res->is_success) or die "Couldn't retrieve " . $uri . " --> " . $res->status_line, "\n";
	my $text = $res->content;
	$text =~ s/\\/\\\\/g;
	$text =~ s/'/\\'/g;
	$text =~ s/\t/\\t/g;
	$text =~ s/\r/\\r/g;
	$text =~ s/\n/\\n/g;
	print "Meeko.stuff.xplSystem.prefetch['" . $uri . "'] = '" . $text . "';\n";
}

sub buildFromUri() {
	my $self = shift;
	my $uri = shift;
	my $fetchURI = $uri;

	$self->{requiredDocuments}->{$uri} and return;
	if (!$uri->scheme) {
		$fetchURI = URI->new_abs($uri, $self->{baseURI});
	}
	elsif ($self->{diskCache}->{$uri}) {
		$fetchURI = URI->new_abs($self->{diskCache}->{$uri}, "file://localhost");
	}
	my $rq = HTTP::Request->new(GET => $fetchURI);
	my $res = $userAgent->request($rq);
	($res->is_success) or die "Couldn't retrieve " . $uri . " --> " . $res->status_line, "\n";
	my $parser = XML::LibXML->new();
	my $document = $parser->parse_string($res->content);
	$self->{requiredDocuments}->{$uri} = $document;
	
	print "Meeko.stuff.xplSystem.createContext('$uri');\n";
	my $node = $document->firstChild;
	while ($node) {
		(1 == $node->nodeType) and last;
		if (7 == $node->nodeType) {
			my $pi = XMLProcessingInstruction->new($node);
			($pi && $pi->target) or next;
			if ("xpl-param" eq $pi->target) {
				print "Meeko.stuff.xplSystem.contexts['$uri'].params['" . $pi->attributes->{name} . "'] = '" . $self->expandParams($pi->attributes->{value}) . "';\n";
			}
			elsif ("xpl-require" eq $pi->target) {
				my $requireHref = $self->expandParams($pi->attributes->{href});
				my $requireUri = URI->new_abs($requireHref, $uri);
				if (!$uri->scheme && !$requireUri->scheme) {
					my $badUri = $requireUri->as_string;
					$badUri =~ s/^\///;
					$requireUri = URI->new($badUri); # work-around when dealing with rel-paths
				}
				print "Meeko.stuff.xplSystem.contexts['$uri'].requiredContexts.push('$requireUri');\n";
				$self->buildFromUri($requireUri);
			}
			elsif ("xpl-prefetch" eq $pi->target) {
				my $prefetchHref = $self->expandParams($pi->attributes->{href});
				my $prefetchUri = URI->new_abs($prefetchHref, $uri);
				if (!$uri->scheme && !$prefetchUri->scheme) {
					my $badUri = $prefetchUri->as_string;
					$badUri =~ s/^\///;
					$prefetchUri = URI->new($badUri); # work-around when dealing with rel-paths
				}
				$self->prefetchFromUri($prefetchUri);
			}
		}
		$node = $node->nextSibling;
	}
	
	my $head = $document->getElementsByTagName("head")->[0];
	my $scripts = $head->getElementsByTagName("script");
	my $scriptText = "";
	for my $script (@$scripts) {
		my $scriptSrc = $script->getAttribute("src");
		if ($scriptSrc) {
			my $fetchUri = URI->new_abs($scriptSrc, $uri);
			if (!$uri->scheme && !$fetchUri->scheme) {
				my $badUri = $fetchUri->as_string;
				$badUri =~ s/^\///;
				$fetchUri = URI->new_abs($badUri, $self->{baseURI});
			}
			my $rq = HTTP::Request->new(GET => $fetchUri);
			my $res = $userAgent->request($rq);
			($res->is_success) or die "Couldn't retrieve " . $fetchUri . " --> " . $res->status_line, "\n";
			$scriptText .= $res->content . "\n";
		}
		else {
			$scriptText .= $script->textContent . "\n";
		}
	}
print <<"";
Meeko.stuff.xplSystem.contexts['$uri'].wrappedScript = function() {
	var xplSystem = Meeko.stuff.xplSystem;
	var xplContext = xplSystem.contexts['$uri'];
	var logger = xplContext.logger;
	$scriptText
}


}

} # end XPLBuilder package

{
	
package XMLProcessingInstruction;

sub new {
	my $class = shift;
	my $node = shift;
	($node && 7 == $node->nodeType) or die "Cannot create XMLProcessingInstruction interface";
	my $self = {};
	bless($self, $class);
	$self->{owner} = $node;
	return $self;
}


sub target { return $_[0]->{owner}->nodeName; }
sub data { return $_[0]->{owner}->getData; }
sub attributes {
	my $self = shift;
	my $data = $self->{owner}->getData;
	my %result = $data =~ /(\w+)="([^"]*)"/g;
	return \%result;
}

}

my $usage = "xpl [--disk-cache uri fname] [--param name value] [--make-depend] file\n";
my $href;

my $xplBuilder = new XPLBuilder;
my $n = scalar @ARGV;

for (my $i=0; $i<$n; $i++) {
	my $arg = $ARGV[$i];
	if ("--help" eq $arg || "-?" eq $arg) {
		print STDERR $usage;
		exit 1;
	}
	elsif ("--param" eq $arg) {
		my $name = $ARGV[++$i];
		my $value = $ARGV[++$i];
		$xplBuilder->{params}->{$name} = $value;
		next;
	}
	elsif ("--disk-cache" eq $arg) {
		my $uri = $ARGV[++$i];
		my $fname = $ARGV[++$i];
		$xplBuilder->{diskCache}->{$uri} = $fname;
		next;
	}
	elsif ("--make-depend" eq $arg) {
		$xplBuilder->{makeDepend} = 1;
	}
	elsif ($arg =~ /^-/) {
		print STDERR "Illegal option " . $arg . "\n" . "Usage:" . $usage;
		exit 1;
	}
	
	else {
		if (!$href) { $href = $arg; }
		else {
			print STDERR "Cannot process more than one file.\nUsage: " . $usage;
			quit();
		}
	}
}

if ($xplBuilder->{makeDepend}) { die "--make-depend option not supported"; }
else { $xplBuilder->build($href); }

__DATA__

if (!window.Meeko) window.Meeko = {};
if (!Meeko.XPL) Meeko.XPL = (function() {

var Namespace = function() {};
Namespace.enhance = function(dest, src) {
	for (var className in src) {
		var srcClass = src[className];
		var destClass = dest[className];
		if (destClass) {
			for (var propName in srcClass) {
				if ("prototype" == propName) continue;
				if (destClass[propName]) continue;
				else destClass[propName] = srcClass[propName];
			}
			if (srcClass.prototype && null == destClass.prototype) destClass.prototype = {}; // NOTE fixes DOMException on Opera and Safari2
			for (var propName in srcClass.prototype) {
				if (destClass.prototype[propName]) continue;
				else destClass.prototype[propName] = srcClass.prototype[propName];
			}
		}
		else dest[className] = srcClass;
	}
}

var Logger = function(ref) {
	this.ref = ref;
}

Logger.DEBUG = 0;
Logger.INFO = 1;
Logger.WARN = 2;
Logger.ERROR = 3;

Logger.prototype.log = function() { this._log({ message: arguments }); }
Logger.prototype.debug = function() { this._log({ level: Logger.DEBUG, message: arguments }); }
Logger.prototype.info = function() { this._log({ level: Logger.INFO, message: arguments }); }
Logger.prototype.warn = function() { this._log({ level: Logger.WARN, message: arguments }); }
Logger.prototype.error = function() { this._log({ level: Logger.ERROR, message: arguments }); }

Logger.prototype._log = function(data) {
	data.date = new Date;
	data.ref = this.ref;
	data.message = Array.prototype.join.call(data.message, " ");
	if (this._trace) this._trace.log(data);
}

var XPLContext = function(ref) {
	this.params = {};
	this.requiredContexts = [];
	this.installed = false;
	this.logger = new Logger(ref);
}

var XPLSystem = function() {
	this.prefetch = {};
	this.contexts = {};
	this.documentURI = document.documentURI || document.baseURI || document.URL;
	this.boundDocumentURI = this.documentURI; // FIXME orthogonality
}

XPLSystem.prototype.createContext = function(ref) {
	if (null == ref) { ref = 0; for (var text in this.contexts) ref++; } // NOTE default value for ref is the current number of contexts;
	var xplContext = new XPLContext(ref);
	this.contexts[ref] = xplContext;
	xplContext.logger._trace = this.trace;
	return xplContext;
}

XPLSystem.prototype.createNamespace = function(name) { // TODO error checking
	var a = name.split(".");
	var ns = window;
	for (var n=a.length, i=0; i<n; i++) {
		var step = a[i];
		if (!ns[step]) ns[step] = {};
		ns = ns[step];
	}
	return ns;
}

XPLSystem.prototype.init = function() {
	var xplSystem = this;
	function require(href) {
		var xplContext = xplSystem.contexts[href];
		if (xplContext.installed) return true;
		for (var n=xplContext.requiredContexts.length, i=0; i<n; i++) {
			require(xplContext.requiredContexts[i]);
		}
		var rc = xplContext.wrappedScript.call(window);
		xplContext.installed = true; // FIXME
		return rc;
	}
	for (var href in xplSystem.contexts) require(href);
}

var Script = function() {
	this.readyState = "initialized";
}

Script.runList = [];

Script.prototype.run = function(text) {
	function setText(_elt, _text) {
		_elt.text = _text;
		if (!_elt.innerHTML) _elt.appendChild(document.createTextNode(_text));
	}
	var scriptElt = document.createElement("script");
	scriptElt.type = "text/javascript";

	this.scriptElement = scriptElt;
	this.scriptIndex = Script.runList.length;
	Script.runList.push(this);

	this.readyState = "loaded";
	setText(scriptElt, 
		'try {\n' +
		text + '\n' +
		' Meeko.XPL.Script.runList[' + this.scriptIndex + '].readyState = "complete";\n' +
		'}\n' +
		'catch (__xplError__) {\n' +
		' Meeko.XPL.Script.runList[' + this.scriptIndex + '].readyState = "error";\n' +
		'}\n'
	);
	
	var callbackElt = document.createElement("script");
	callbackElt.type = "text/javascript";
	
	this.callbackElement = callbackElt;
	setText(callbackElt, 'window.setTimeout(function() { Meeko.XPL.Script.runList[' + this.scriptIndex + '].callback(); }, 10);');

	var head = document.getElementsByTagName("head")[0];
	head.appendChild(scriptElt);
	head.appendChild(callbackElt);
}

Script.prototype.callback = function() {
	var head = this.scriptElement.parentNode;
	head.removeChild(this.scriptElement);
	head.removeChild(this.callbackElement);
	if (this.readyState == "error") {
	}
	else if (this.readyState == "loaded") {
		this.readyState = "syntax-error";
	}
	if (this.onreadystatechange) this.onreadystatechange();
}


return {
	Namespace: Namespace,
	XPLContext: XPLContext,
	XPLSystem: XPLSystem,
	Script: Script
}

})();

if (!Meeko.stuff) Meeko.stuff = {};
Meeko.stuff.xplSystem = new Meeko.XPL.XPLSystem();
var traceWindow = this;
do {
	if (traceWindow && traceWindow.Meeko && traceWindow.Meeko.stuff && traceWindow.Meeko.stuff.trace) {
		Meeko.stuff.xplSystem.trace = {
			_log: traceWindow.Meeko.stuff.trace.log,
			log: function(data) {
				data.url = Meeko.stuff.xplSystem.documentURI; 
				data.boundDocumentURI = Meeko.stuff.xplSystem.boundDocumentURI; // FIXME orthogonality
				this._log(data);
			}
		}
		break;
	}
	if (traceWindow == top) break; // need to break at top because top.parent == top
} while (traceWindow = traceWindow.parent);

if (!Meeko.stuff.xplSystem.trace) {
	Meeko.stuff.xplSystem.trace = {
		log: function(data) {}
	}
}

Meeko.stuff.execScript = function(text, callback) {
	var script = new Meeko.XPL.Script;
	if (callback) script.onreadystatechange = function() { callback(script.readyState); };
	script.run(text);
}

Meeko.stuff.evalScript = function() {
	return eval(arguments[0]);
}

// NOTE emulate firebug behavior which complements the XMLHttpRequest wrapper in Meeko.xml
if (XMLHttpRequest && !XMLHttpRequest.wrapped) var XMLHttpRequest = (function() {
	var _xhr = window.XMLHttpRequest;
	var xhr = function() { return new _xhr; };
	xhr.wrapped = _xhr;
	return xhr;
})();

// NOTE cross-browser error catch-all
//if (window.addEventListener) window.addEventListener("error", function(event) { event.preventDefault(); }, false);
//else window.onerror = function(event) { return true; }; // FIXME

